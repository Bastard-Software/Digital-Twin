#version 450
layout(local_size_x = 256) in;

struct Cell {
    vec4 position;
    vec4 velocity;
    vec4 color;
    uint meshID;
    float padding[3];
};

// Binding 0: Global Data
layout(std140, binding = 0) uniform GlobalData {
    float dt;
    float time;
    vec2  resolution;
    float viscosity;
    float gravity;
    float padding[2];
} u_Global;

// Binding 2: OUTPUT Buffer (Read/Write)
// We are modifying the data written by the collision step.
// Notice we do NOT use binding 1 (InPopulation) here based on your main.cpp logic.
layout(std430, binding = 2) buffer OutPopulation {
    Cell cellsOut[];
};

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // Safety check
    if (idx >= cellsOut.length()) {
        return;
    }

    // 1. Read the cell (modified by previous kernel in this frame)
    Cell c = cellsOut[idx];

    // 2. Apply movement
    // pos = pos + vel * dt
    c.position.xyz += c.velocity.xyz * u_Global.dt;

    // 3. Write back
    cellsOut[idx] = c;
}