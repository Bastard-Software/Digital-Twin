#version 450
layout(local_size_x = 256) in;

// Must match C++ struct alignment (16-byte align for vec4)
struct Cell {
    vec4 position;
    vec4 velocity;
    vec4 color;
    uint meshID;
    float padding[3]; // Padding to match C++ alignment (16 bytes total for last chunk)
};

// Binding 0: Global Uniform Data
layout(std140, binding = 0) uniform GlobalData {
    float dt;
    float time;
    vec2  resolution;
    float viscosity;
    float gravity;
    float padding[2];
} u_Global;

// Binding 1: INPUT Buffer (Read-Only, Previous State)
layout(std430, binding = 1) readonly buffer InPopulation {
    Cell cellsIn[];
};

// Binding 2: OUTPUT Buffer (Write-Only, Next State)
layout(std430, binding = 2) buffer OutPopulation {
    Cell cellsOut[];
};

void main() {
    uint idx = gl_GlobalInvocationID.x;

    // Safety check against buffer size
    if (idx >= cellsIn.length()) {
        return;
    }

    // 1. Read from Previous State (Input)
    Cell c = cellsIn[idx];

    // 2. Physics Logic
    // Apply gravity to velocity
    c.velocity.y -= u_Global.gravity * u_Global.dt;

    // Simple ground collision (floor at y = -10.0)
    if (c.position.y < -10.0) {
        c.position.y = -10.0;
        // Simple bounce with damping
        c.velocity.y *= -0.8;
    }

    // 3. Write to Next State (Output)
    cellsOut[idx] = c;
}